##For DP
##斐波那契数
class Solution:
    def fib(self, n: int) -> int:
        if n<2:
            return n       
        p,q,r=0,0,1
        for i in range(2,n+1):
            p,q=q,r
            r=p+q
        return r
##第 N 个泰波那契数：
class Solution:
    def tribonacci(self, n: int) -> int:
        if n<3:
            return 1 if n else 0
        x,y,z=0,1,1
        for _ in range(n-2):
            x,y,z=y,z,x+y+z
        return z
##台阶问题：找到初始0阶是0步，1阶是1步，2阶是0+1阶步
class Solution:
    def climbStairs(self, n: int) -> int:
        x,y=0,1
        for i in range(n):
            z=y+x
            x,y=y,z
        return z
##使用最小花费爬楼梯：给定一个代表爬每层楼梯的花销，每次可以爬一层或者两层。初始状态是dp[0]=dp[1]=0，状态转移方程：
dp[i]=min(dp[i−1]+cost[i−1],dp[i−2]+cost[i−2])
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        pre,curr=0,0
        n=len(cost)
        for i in range(2,n+1):
            next=min(curr+cost[i-1],pre+cost[i-2])
            pre,curr=curr,next
        return curr
##打家劫舍
##首先考虑最简单的情况，只有一间则偷一间，有两间偷最大，对于K>2的情况，有两种：1）偷窃第K间，那么就不能偷K-1间，应该是前K-2间最大
加第K间的金额；2）不偷窃第K间，偷窃总金额为前K-1间最大，用dp[i]表示前i间房屋能偷窃到的最高总金额，那么状态转移方程如下：
dp[i]=max(dp[i-2]+nums[i],dp[i-1])
边界条件：
1) dp[0]=nums[0] 只有一间房屋，则偷窃该房屋
2) dp[1]=max(nums[0],nums[1]) 只有两间房屋，选择其中金额较高的房屋进行偷窃
​class Solution:
    def rob(self, nums: List[int]) -> int:       
        n=len(nums)
        if n==1:
            return nums[0]
        first,second=nums[0],max(nums[0],nums[1])    
        for i in range(2,n):
            res=max(first+nums[i],second)
            first,second=second,res
        return second

​
##打家劫舍2：在原来版本的基础上，规定首尾不能同时偷。分析：在原来的基础上分两种情况：如果偷了头，那么不能偷最后一间；如果偷了最后一间，不能偷第一间。
假设偷窃房屋的下标范围是 [start,end]，用 dp[i] 表示在下标范围 [start,i] 内可以偷窃到的最高总金额，那么就有如下的状态转移方程：
dp[i]=max(dp[i−2]+nums[i],dp[i−1])
边界条件为：

1）dp[start]=nums[start] 只有一间房屋，则偷窃该房屋
2）dp[start+1]=max(nums[start],nums[start+1]) 只有两间房屋，偷窃其中金额较高的房屋
class Solution:
    def rob(self, nums: List[int]) -> int:
        def robRange(start: int, end: int) -> int:
            first = nums[start]
            second = max(nums[start], nums[start + 1])
            for i in range(start + 2, end + 1):#因为dp[i]表示第i个位置的总金额，所以要end+1才可以取到end的值
                first, second = second, max(first + nums[i], second)
            return second
        
        length = len(nums)
        if length == 1:
            return nums[0]
        elif length == 2:
            return max(nums[0], nums[1])
        else:
            return max(robRange(0, length - 2), robRange(1, length - 1))	
计算得到 dp[end] 即为下标范围 [start,end] 内可以偷窃到的最高总金额。
分别取 (start,end)=(0,n−2) 和(start,end)=(1,n−1) 进行计算，其中n-2是倒数第二件，n-1是最后一间，取两个dp[end] 中的最大值，即可得到最终结果。
小结：打家劫舍2相对于打家劫舍1，约束在于需要分情况讨论包含第一间和最后一间如何得到正确结果，所以DP很多时候初始值，边界条件，分情况讨论很重要。
###删除并获得点数：当选择了某个数，该数存在重复，那么第一次选择该数时就已经把该数+1和该数-1的值给删掉了，后面该数就可以随便删除（即相加）
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        maxVal = max(nums)
        total = [0] * (maxVal + 1)#构建连续数组maxVal大小，其中以原数组nums中的数值为新数组total的下标，这样子原来的+1 和-1问题就成了新数组的位置问题，转换成了邻居不能偷概念
        for val in nums:
            total[val] += val
        
        def rob(nums: List[int]) -> int:
            size = len(nums)
            first, second = nums[0], max(nums[0], nums[1])
            for i in range(2, size):
                first, second = second, max(first + nums[i], second)
            return second
        
        return rob(total)


